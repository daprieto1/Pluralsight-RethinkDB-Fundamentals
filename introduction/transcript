Introduction
Introduction
Welcome to RethinkDB Fundamentals here at Pluralsight. My name's Rob Conery, and I'll be your host for this course. If you need to get ahold of me, you can use the Twitter address or the email that you see onscreen, or you can just leave a note here in the discussions. In this course, we're going to get to know RethinkDB and why it deserves your attention. We'll get into query syntax, administration, and some tips and techniques, including integrating with a full-text indexing service, like Elastic Beanstalk. Before we do anything, however, let's go over why you should care about RethinkDB when there are so many choices out there. I'll get into each of these topics in detail later on, but upfront, there is a lot of exciting things happening with this system. 2. 0 is just around the corner, and it's the result of three years of careful development and tweaking. This is the release that many have been waiting for, and it's what we're going to use today. Like many other systems, RethinkDB is fast, it's very scalable, and it's fun to use. Its build is a next generation document database, the best of what we've learned over the last few years wrapped in a beautiful system. RethinkDB also supports joins. That is a rarity for document databases. Finally, it's amazingly easy to administer, as you're about to see in one minute and 37 seconds. Many people claim, including the RethinkDB folks, that RethinkDB is MongoDB done right. RethinkDB is using all the best features of MongoDB and learning from the not so good, but it's not stopping there. The RethinkDB team has tried to create a database system that sits right in the middle of the biggest systems out there, a Goldilocks database if you will. This quote from the RethinkDB blog captures the experience of working with the database perfectly. "It's fun to work with as well as to administer, "if you can believe it. " When's the last time you heard that about a document database? Riak and Cassandra are the well known, large-scale systems that power incredibly active data sets. Cassandra was developed by the Facebook team and is now used at Twitter as well. On the other hand, CouchDB and MongoDB kicked off the document database revolution many years ago, enabling a whole new way of storing data and also causing a lot of sleepless nights for administrators trying to figure out various problems. RethinkDB sits right between these use cases. High write capabilities, durable, and also easy to use for developers. For administrators, RethinkDB is a dream. RethinkDB ships with a web-based admin interface that comes online immediately. From here, you can do all kinds of things, from creating databases and tables to sharding, or replicating a selected table. Setting up a shard is only seconds away and can be done entirely in the web interface. You can query your data using the flexible and functional RethinkDB query language named ReQL. The interface is gorgeous, and you can view your results in a tree, a table, or a JSONView. There's so much to see and so much I haven't even shown you yet. Hopefully, you're as excited as I am to start working with this database. Speaking of, in this course, we're going to get to know RethinkDB and how it works. We'll cover a wide variety of topics, including an introduction to RethinkDB and what sets it apart. That's the rest of this module. We'll do some basic querying, inserts, updates, reads, and so on. Then we'll get into advanced topics. We'll do analytic queries, we'll create secondary indexes, and we'll optimize our database so it's nice and fast. Then we'll get into administration. We'll shard, we'll replicate, we'll get into failover, I'll crater some servers, take them offline completely and try and rehabilitate my cluster. That's a lot of fun. Then we'll get into tips and techniques. We'll add full-text indexing. We will also do some geospatial queries. We'll take a look at compose. io and then see different ways you can deploy your server. People who read my blog or have watched other courses I've done here at Pluralsight will know that I'm a huge fan of Postgres. It too is the best of both worlds. It's an amazing relational engine, fully ACID compliant, that now has binary JSON support, so it's kind of going into the whole no-sequel thing. That pits it squarely against systems like RethinkDB and MongoDB. Well, let me tell you, nothing has changed. Both systems are amazing and I love them both, and believe it or not, I am capable of that. Now they overlap in many, many ways, but there's some small differences. Specifically, RethinkDB's query language is superior by far for querying documents. RethinkDB is easier to manage with a gorgeous UI. Postgres has a huge community, and answers to your questions are close at hand. So the short answer is no answer at all. Try them both. See which feels right to you. I love them both, and the current project I'm working on, I'm actually using both. I like to code, and I think watching the coding process is far more fun and educational than a barrage of concepts set out in slides. So that's what you're going to get here. I'll be coding a lot, and I hope that you code along with me. I've done my best to make sure that you have the data resources that you need to play along, and I've also tried to make this course as code-centric as possible. I'll have a few slides here and there, but for the most part, it's me and my horrible typing. Speaking of, let's get to it.

Is RethinkDB Right for You?
There's so many good choices when it comes to document data stores, even whether you should use one at all. Let's go over the reasons RethinkDB may or may not be a good fit. I'll just cut to it right now. RethinkDB is the most impressive no-sequel solution that I have ever seen. I am so impressed with it, from its functional ReQL language to its ease of use and its speed. Really, it's hard to see a reason why it can't work for you, but there are some considerations, so let's have a look. Specifically, what makes RethinkDB a good choice? You'll enjoy working with it if you like having flexible schemas. No more migrations. Just write your JSON to RethinkDB and it's saved. If you use an external system like Hadoop to run routine analytics, key word, routine, RethinkDB can take over for you. Using sharding and replication, you can keep your data in sync, but you can run your analytics completely on a separate server if you want. Finally, if managing your MongoDB or other document store system is a drag, well, RethinkDB can make your life a much better place to live. Now, conversely, RethinkDB might not be a good choice if you need to rely on your database schema directly or you have to have ACID support for some reason. RethinkDB enforces safe writes out of the box, meaning you have to tell it that you're willing to forego data safety in the name of speed. However, some people need more than that. If that's you, RethinkDB might not be a good fit. If you're running some deep analytics, you'll find RethinkDB's query language a bit confining. It can handle a lot, but it is not an analytical system. Finally, if you're running a system like Twitter or Papertrail that need blazing write speeds, you might be better off using Cassandra or Riak. RethinkDB does allow you to tweak write speed, as you're about to see, but it really is not designed for that. And that's RethinkDB. It sits right in the middle of high-end systems out there, allowing you the best of both worlds without going too far in each one. It's a lot of fun to use, and you can feel it the minute you install it and open up the administrative interface.

Installation
Let's get started by installing RethinkDB, and I'll do this on my Macintosh, and there's a couple of different ways to do it. So start off by heading over to rethinkdb. com. And here, you can see the install link right there at the top, I love that. And the version they have up there is version 1. 16. 2. Actually, the latest is 1. 16. 3, as I record this now, but anyway. If you click on install, it will take you to, guess what? The installation page. Here, you can see all your different choices for installing RethinkDB. There's a Ubuntu, OS X, CentOS, et cetera, and you know. RethinkDB does not run on Windows. However, you are a capable developer, and if you're running on Windows and you want to play along today, kick up an Ubuntu VM, and right here are instructions for installing on Ubuntu. And you can just follow these directly from their site. It's a real quick and easy installation. Setting up a VM is simple. Head over to Azure, or whatnot. You can also download and install the OS X installer if you're using a Mac, like I am. You can download the installation, as you see here on the top left, or you can just use Homebrew. Either one works really well. If you want it completely isolated, maybe using Homebrew might be better. But for today, I will be using RethinkDB 2. 0. And you can see the release announcement post right here. Read it if you like, full of good information. However, if you go down to the bottom, you can see a link to their GitHub repo, where you can download the 2. 0 release candidate one, which by the time you watch this, well, you're probably not going to need to do this. I believe 2. 0 is going to be released by the time this video pops, but just in case it's not, here's instructions for downloading and using the OS X release candidate. All right, once you have it installed, let's check our version. You do this by typing rethinkdb -v into the command line, as I've done here. You can see, I'm running 2. 0 release candidate one. Typing in --help, you can take a look at the commands that are available to you as well as a few other things. But notice, there's not all that many commands to working with RethinkDB. It is bleedingly simple. In fact, to actually run RethinkDB, you just don't have to enter anything at all. We'll come back to some of these commands later on. For now, let's start RethinkDB. And there you are. It starts right up. This is something to note straight away, that when you start RethinkDB, it will initialize a data directory right in the directory where you started it from. And it calls this rethinkdb_data. I kind of like this, because it keeps all your data files easily accessible and manageable. And the next thing to take note of here in the log splash is that you have three different ports that you're going to have to remember. 29015, 28015, and 8080. We'll talk about the first two later on, but 8080 is the one that I am most interested in, because that is the administrative interface. Taking a look at our directory here, where we launched RethinkDB, this is it. That's the data file right there. If you want to get rid of your database, just delete the data file. That might sound a little scary, but for development, it makes life easy. Let's head over to the administrative screen and go to localhost and then 8080, and take a look around, and here it is. That's the administrative interface. It's gorgeous, and it's simple. It's easy to use, and it's also aware. It gets push notifications from the server itself, so when anything changes, you're notified immediately. For instance, let's see what happens when we shut our server off. This'll give you a good idea of how well the team has thought through this admin interface. Look at that. You have been disconnected from the server, and it grays things back. It doesn't sit there and try and cycle and execute commands on a dead server. All right, for now, let's remove our RethinkDB data directory, and as you can see here, it's gone. The reason I'm doing this is because I want to reconfigure my server. I want to launch it with different options. And to see those options, type in --help. Specifically, I don't like the name that it gave my server. It just kind of came up with one. It was the name of my machine and then some random characters. I'd rather have a name that means something. So scrolling all the way to the top here, you can see the -n flag. That means server name, or --server-name, if you want to be more clear. d would be if I wanted to specify the exact data directory. I'll just leave that alone. What I think I want to do is I just want to start it up with a name. And I'm going to call my server Zayn. And there it is. It's all set up and ready and running. And it's worth pointing out that if you just turn off your server and try and start it again using -n, well that would not rename your server. RethinkDB is a little bit more robust than that. However, if you wanted to rename it through the admin interface, you certainly can. We'll deal with renaming servers later on.

Altering Schemas
Let's play around with some schemas. We'll create a database or two and also some tables. Here, I have the administrative screen open, and I can just go to add a database here in the tables window. And I can also add a table. And just like that, I have a database named music, I have a table named artists, and I have another one, now, called invoices. Now I don't need to accept the defaults. Specifically, RethinkDB will create an ID automatically for my document called id. If I didn't want that, I could specify a different key here. Now take a look at the toggle at the very, very bottom here, the one that says, "Acknowledge writes only "when written to disk. " This is known as hard durability, and all tables in RethinkDB have hard durability by default. You have to switch it off. What this means is, when you insert some data, it'll take a little bit longer for RethinkDB to respond to you, so inserts can slow down. If you want to speed things up, you can turn hard durability off, in other words, setting it to soft. Now let's head over to the Data Explorer. This is where we get to play with the data that's in our database. I don't have any just yet, but maybe we can add some and goof around. First thing to notice is we have code completion. This is one thing I absolutely love about RethinkDB. It makes learning ReQL, the query language, really easy. All these little popups tell you the things that you can do with the various entries that you have. Here, I'm just going to tell it to list all the tables in my database. And when I hit run, I can see a JSONView down below. It's just an array of strings, artists and invoices. I can switch this over to a table view if I want, and there we go. One thing I really appreciate working with the Data Explorer is the way that it intelligently handles its code completion. Here, it knows I'm working with a table, and so it's going to pop up all the choices that I have for working with a table query. And you can see all the different choices that we will get to more later on. And you've probably been noticing that I've been typing r. a lot, and r is the root name space for working with RethinkDB. There's a number of things on here. There's conversions, there's root level objects, there's commands like do, there's things where you want to specify a literal. You can work with dates. But most often, you'll just be specifying what to do with the database. In this case, if you want to drop one, like I just did, you can do that. And look at this. This is one of the really neat things about working with RethinkDB. It tells you what just happened. DBs dropped, tables dropped, too. It's telling us the old value, that was the name of the database, music, and the new value is null, meaning it's not there. And if we head over to our tables window here and take a look, yep, it's not there. It's all gone. So you don't have to do everything through the admin screen. You can do it all right here in the Data Explorer. Let's create our database again, and I'll use r. dbCreate and then, there we go. You can see the changes down below. Dbs_created, one, and the next thing I do here is I can actually create a table, too, tableCreate and artists. It's that simple. ReQL is pretty simple stuff, and there's just a few things you got to learn. Okay, so I'm creating my tables here, artists and invoices, and I've got my new database, music. Let's head back over to the tables window, and there it is. Music database, and the artists and invoices tables. Now let's switch gears a little bit, and I want to show you one of the best things about ReQL and working with RethinkDB. This is the directory that I've been working in. As you can see, I just have my data directory for my database. Let's make a directory for a Node application, and I'll call it app. And, using npm, I'll initialize our application using npm init. And in here, I'll just kind of scoot on down through all of this stuff, and well, I got to just leave my name in here, as the author, why not? Yep, that looks pretty good. Okay, so now that we have a package. json, we can install the RethinkDB driver. And we can do this by just saying npm install rethinkdb --save. Now you might be wondering, Rob, why are you doing this? Why are we looking at Node? Aren't we supposed to be working with RethinkDB? And yes, of course, we are. However, when it comes to working with databases and booting them up, most of the time, you're probably going to be working with some kind of bootstrap file. That's what I'm creating here. I'm using the Atom text editor, and I wanted to show you how simple it is to use the RethinkDB driver to do some of the basic schema manipulations that you're going to need to do. Here, I'm just using the driver to connect to our local database, and notice the syntax. It almost directly mirrors what I wrote in the Data Explorer. Here, I'm just using r. dbCreate, our music database, and then I'm telling it to run, and I'm passing the live connection that was handed to us from the connect function above. This is the beginnings of our database bootstrap file for our project. And when you're working with RethinkDB, or any database, really, you're probably going to have a bootstrap file like this. So when team members come on the project, they can get up and running quickly. Speaking of, if we run this using the Atom's Runner, you can see, boom, we have a new database that was created for us against our local RethinkDB server. The next step, of course, is to be able to install the tables that we'll be using. For this, I want to be able to execute things in step in an asynchronous way. So I'll use an asynchronous manager for this. I could use eventing and a bunch of other things, but I find sometimes, just using the Async library is the easiest possible thing. So, and I'll reference Async above, and then, down below here, I'll create a few methods for working with our database. In fact, let's kind of orchestrate this a little bit better. Rather than calling r. connect in line, I think I'm going to try and make things a little bit better on the eyes. And so here, I have createDb, and I also have createTable. Let's move our connection inside of the createDb function, and then we'll just call next once that's finished. All right, well as exciting as this might be, I'm not going to make you watch me type this all out. So let's skip ahead a little bit, and you can see, a fairly typical bootstrap file. Creating the database, and then I have a createTable function, and then down below here, I am using async. map. That's going to call a function multiple times, depending on what values you have in the array. So in our array here, I have two string values, artists and invoices. That's going to call createTable multiple times and pass the name of our tables in. Finally, down below here, I'm using async one more time, telling it to create the database first, and then call createTables. All right, so, let's go back to the web interface and you can see, I have got no databases, no tables, nothing in our local server. They're all gone. So using the Atom Runner that I've installed, that's the Atom Runner package, and I run this, and boom! Everything has run pretty well, looks like. Database was created. Looks like the tables were created. I got an array of config changes back. Let's head it back over to the admin screen. And just like that, it's updated itself. I don't have to refresh. This thing is aware of the database, and if it sees any changes, like when you saw before, the server goes offline, or when a table is added or any other information that we need to know about, the admin screen will update itself.

Simple Import
Let's import some data into our database, and along the way, we'll see what we can do to improve our write speed. Notice here that our artists table has zero documents. And if we go over to our Data Explorer and we run this query, yep. No results returned. So we had absolutely no data. Let's head back over to our text editor, Atom, and in here you can see I have a new directory called data. And inside of it, I have two JSON files. And they're dumps from the Chinook database. And I just dumped them to disk here. In addition, I have renamed my index. js file to bootstrap. js, just so you know. So when you download the project, you can see all the files are in there. All right, so we are going to connect to our music database, and I am then going to just require the artists JSON file. And that's going to pull it in. That means I can just loop over every value that's in that JSON file and then insert it directly, one at a time. Simple pimple. This is how you do an insert. You just do insert and then the document, and then you have to tell the driver to run. That's really important, and a lot of people forget that. All right, we're running this, oh boy. That did not go very fast. I have exactly 204 records, those are all the artists in the database. And it took 2. 246 seconds. Hm, that's a little bit slow. We'll have to improve that. All right, well let's head back over to the web interface and make sure we have some data. And I'll zoom in on this, so we can see the query better. And if I hit run, yep. We have lots of data, all the artists are in there. And notice that it only returns 40 rows at a time. It doesn't blow your browser up, which I really like. So if I type in. count, chain that method on there, you can see I have 204 records. And I can also delete them by adding. delete. They're all gone now. (laughs softly) So that is how you delete data in RethinkDB. All right, the reason I deleted it is because I want to enter the data again, but I want to do it smarter. So, to speed things up, I have a couple of options. The first is to turn hard durability off, and I can do this right here in the insert call. I don't need to go and change the configuration of the table. So once again, to remind you, soft durability means that RethinkDB will acknowledge that the write is in, but it does not wait for it to be persisted to disk. Hard durability on the other hand, means that the acknowledgement only happens when the data gets written to disk. Okay, so just by flipping the durability to soft, let's run this one more time with the Atom Runner. And look at that. That was a dramatic speed improvement. In fact, I believe it took a half a second. Yep,. 466 seconds, that is a much better time for writing. However, it should be noted that if you're trying to speed things up, setting durability to soft might not always be your best choice. Let's take a look at other ways that we can speed things up. So first thing I want to do is let's flip back over to the web interface, and I want to make sure that I delete all the data. And, boom, it's all gone. Okay, let's flip back over into the code and see what else we can do here to speed things up. I can set noreply to true. By default, every time you do any operations on data in RethinkDB, it'll send back some form of acknowledgment, some kind of JSON record. We've already seen this when we've dropped and created databases and tables. Here, I'm just saying, I don't care if you want to acknowledge that the insert happened. Just don't tell me, I believe you. This is not the same as soft durability. If we run this, you can see, it is very fast, but there's a slight delay. It's still 2. 5 seconds, but our code wasn't prevented from moving on. As you saw, the 204 records are splashed right out to the screen. With a notification down below, that took a little bit longer. That's because before we're able to close the connection, all the writes had to be acknowledged, although the driver didn't tell us about 'em. So it looks to us like it sped up. All right, well what happens if we set durability to soft and noreply to true? Let's try it out, and boom. Everything goes really fast, but it's the same effect as having durability soft. It's about a half second for all of the writes to go in. So really there's no gain for that. What we really should be doing here is we shouldn't be looping over the records and executing a run each time. Even though we have a live connection, executing individual writes like this is very slow. What we really want to do is insert the entire array at once. The driver is smart enough to know, oh, these are individual artists records. Next, I'll remove the durability and noreply settings, and then down below, instead of console. logging our counter, which would be one, I'll just put the length of the array, just so we can see how many records were inserted. And running it, that is pretty quick. That, again, is hard durability, and we're down to about a half-second count now, just by inserting an array instead of the individual artists. All right, now let's see what happens if I set durability to soft. What do you think's going to happen? If soft durability on that array, eh, you know what? Not that much of a win. So we're kind of close, which is great. This means, is that RethinkDB is really fast at writing, especially if you want to write an array, you want hard durability, but you don't want to wait for the acknowledgment. Here, it went in almost instantaneously. And our program can go on and process other things.

